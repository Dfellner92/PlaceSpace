{"ast":null,"code":"import _regeneratorRuntime from\"/Users/danielfellner/Desktop/postBootcampProjects/Frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/danielfellner/Desktop/postBootcampProjects/Frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _slicedToArray from\"/Users/danielfellner/Desktop/postBootcampProjects/Frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{useState,useCallback,useRef,useEffect}from'react';// useCallback will ensure this hook doesn't get \n//infinitely rerendered.\nexport var useHttpClient=function useHttpClient(){var _useState=useState(false),_useState2=_slicedToArray(_useState,2),isLoading=_useState2[0],setIsLoading=_useState2[1];var _useState3=useState(),_useState4=_slicedToArray(_useState3,2),error=_useState4[0],setError=_useState4[1];// useRef will store data across rerendered\n//cycles\nvar activeHttpRequests=useRef([]);var sendRequest=useCallback(/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(url){var method,body,headers,httpAbortCtrl,response,responseData,_args=arguments;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:method=_args.length>1&&_args[1]!==undefined?_args[1]:'GET';body=_args.length>2&&_args[2]!==undefined?_args[2]:null;headers=_args.length>3&&_args[3]!==undefined?_args[3]:{};setIsLoading(true);httpAbortCtrl=new AbortController();activeHttpRequests.current.push(httpAbortCtrl);_context.prev=6;_context.next=9;return fetch(url,{method:method,body:body,headers:headers});case 9:response=_context.sent;_context.next=12;return response.json();case 12:responseData=_context.sent;activeHttpRequests.current=activeHttpRequests.current.filter(function(reqCtrl){return reqCtrl!==httpAbortCtrl;});if(response.ok){_context.next=16;break;}throw new Error(responseData.message);case 16:setIsLoading(false);return _context.abrupt(\"return\",responseData);case 20:_context.prev=20;_context.t0=_context[\"catch\"](6);setError(_context.t0.message);setIsLoading(false);throw _context.t0;case 25:case\"end\":return _context.stop();}}},_callee,null,[[6,20]]);}));return function(_x){return _ref.apply(this,arguments);};}(),[]);// const clearError = () => {\n//     setError(null)\n// };\nuseEffect(function(){return function(){activeHttpRequests.current.forEach(function(abortCtrl){return abortCtrl.abort();});};},[]);return{isLoading:isLoading,error:error,sendRequest:sendRequest};};","map":{"version":3,"sources":["/Users/danielfellner/Desktop/postBootcampProjects/Frontend/src/shared/hooks/http-hook.js"],"names":["useState","useCallback","useRef","useEffect","useHttpClient","isLoading","setIsLoading","error","setError","activeHttpRequests","sendRequest","url","method","body","headers","httpAbortCtrl","AbortController","current","push","fetch","response","json","responseData","filter","reqCtrl","ok","Error","message","forEach","abortCtrl","abort"],"mappings":"ghBAAA,OAASA,QAAT,CAAmBC,WAAnB,CAAgCC,MAAhC,CAAwCC,SAAxC,KAAyD,OAAzD,CAEA;AACA;AACA,MAAO,IAAMC,CAAAA,aAAa,CAAG,QAAhBA,CAAAA,aAAgB,EAAM,eACGJ,QAAQ,CAAC,KAAD,CADX,wCACxBK,SADwB,eACbC,YADa,8BAELN,QAAQ,EAFH,yCAExBO,KAFwB,eAEjBC,QAFiB,eAI/B;AACA;AACA,GAAMC,CAAAA,kBAAkB,CAAGP,MAAM,CAAC,EAAD,CAAjC,CAEA,GAAMQ,CAAAA,WAAW,CAAGT,WAAW,0FAAC,iBAC5BU,GAD4B,8LAE5BC,MAF4B,+CAEnB,KAFmB,CAG5BC,IAH4B,+CAGrB,IAHqB,CAI5BC,OAJ4B,+CAIlB,EAJkB,CAM5BR,YAAY,CAAC,IAAD,CAAZ,CACMS,aAPsB,CAON,GAAIC,CAAAA,eAAJ,EAPM,CAQ5BP,kBAAkB,CAACQ,OAAnB,CAA2BC,IAA3B,CAAgCH,aAAhC,EAR4B,sCAUDI,CAAAA,KAAK,CAACR,GAAD,CAAM,CAC9BC,MAAM,CAANA,MAD8B,CAE9BC,IAAI,CAAJA,IAF8B,CAG9BC,OAAO,CAAPA,OAH8B,CAAN,CAVJ,QAUlBM,QAVkB,sCAgBGA,CAAAA,QAAQ,CAACC,IAAT,EAhBH,SAgBlBC,YAhBkB,eAkBxBb,kBAAkB,CAACQ,OAAnB,CAA6BR,kBAAkB,CAACQ,OAAnB,CAA2BM,MAA3B,CACzB,SAAAC,OAAO,QAAIA,CAAAA,OAAO,GAAKT,aAAhB,EADkB,CAA7B,CAlBwB,GAsBnBK,QAAQ,CAACK,EAtBU,+BAuBd,IAAIC,CAAAA,KAAJ,CAAUJ,YAAY,CAACK,OAAvB,CAvBc,SA0BxBrB,YAAY,CAAC,KAAD,CAAZ,CA1BwB,gCA2BjBgB,YA3BiB,4DA6BxBd,QAAQ,CAAC,YAAImB,OAAL,CAAR,CACArB,YAAY,CAAC,KAAD,CAAZ,CA9BwB,uFAAD,+DAiC5B,EAjC4B,CAA/B,CAmCA;AACA;AACA;AAEAH,SAAS,CAAC,UAAM,CACZ,MAAO,WAAM,CACVM,kBAAkB,CAACQ,OAAnB,CAA2BW,OAA3B,CAAmC,SAAAC,SAAS,QAAIA,CAAAA,SAAS,CAACC,KAAV,EAAJ,EAA5C,EACF,CAFD,CAGH,CAJQ,CAIN,EAJM,CAAT,CAMA,MAAO,CAAEzB,SAAS,CAATA,SAAF,CAAaE,KAAK,CAALA,KAAb,CAAoBG,WAAW,CAAXA,WAApB,CAAP,CACH,CAtDM","sourcesContent":["import { useState, useCallback, useRef, useEffect } from 'react';\n\n// useCallback will ensure this hook doesn't get \n//infinitely rerendered.\nexport const useHttpClient = () => {\n    const [isLoading, setIsLoading] = useState(false);\n    const [error, setError] = useState();\n\n    // useRef will store data across rerendered\n    //cycles\n    const activeHttpRequests = useRef([]);\n    \n    const sendRequest = useCallback(async (\n        url, \n        method = 'GET', \n        body = null, \n        headers = {}\n    ) => {\n        setIsLoading(true);\n        const httpAbortCtrl = new AbortController();\n        activeHttpRequests.current.push(httpAbortCtrl);\n        try {\n            const response = await fetch(url, {\n                method,\n                body,\n                headers\n            });\n    \n            const responseData = await response.json();\n           \n            activeHttpRequests.current = activeHttpRequests.current.filter(\n                reqCtrl => reqCtrl !== httpAbortCtrl\n            );\n\n            if (!response.ok) {\n                throw new Error(responseData.message);\n            }\n\n            setIsLoading(false);\n            return responseData;\n        } catch (err) {\n            setError(err.message);\n            setIsLoading(false);\n            throw err;\n        }\n    }, []);\n\n    // const clearError = () => {\n    //     setError(null)\n    // };\n\n    useEffect(() => {\n        return () => {\n           activeHttpRequests.current.forEach(abortCtrl => abortCtrl.abort()); \n        };\n    }, []);\n\n    return { isLoading, error, sendRequest }\n};"]},"metadata":{},"sourceType":"module"}